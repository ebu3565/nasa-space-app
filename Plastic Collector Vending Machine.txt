1) System design (quick overview)

User flow

User taps an RFID card (or you generate an anonymous session/QR).

User inserts a plastic bottle into the chute.

Sensors verify: presence (IR beam) + approx. size (ultrasonic in chute) + weight (load cell).

If valid plastic item → gate/auger motor pulls it into the bin.

Fill-level sensor checks capacity; stop if full.

ESP32 sends a JSON record to your web app.

(Optional) Print a receipt / QR for rewards, or credit the user’s RFID account.

Core modules

Controller: ESP32 (built-in Wi-Fi, plenty of I/O)

Bottle detection: IR break-beam pair at chute entrance

Size check (optional): Ultrasonic sensor inside chute pointing across diameter

Weight: 5–20 kg load cell + HX711 amp under the capture tray

Gate/drive:

option A: Solenoid latch → drops bottle into bin

option B: Stepper motor + A4988 driving a short auger/roller (anti-jam)

User ID: MFRC522 RFID (or skip for anonymous)

Display & input: 20×4 I²C LCD + 4×4 keypad (or just 2 buttons)

Bin full: Top-down ultrasonic in the bin

Safety: Door sensor (reed switch), E-stop, motor driver fuse, over-temp cutoff

Power: 12 V (motors/solenoid) + 5 V rail; ESP32 gets 5 V via buck, common ground

(Optional): TTL thermal printer for receipts

2) Suggested pin map (ESP32)

You can change these in the code.

I²C LCD: SDA GPIO 21, SCL GPIO 22 (addr 0x27 or 0x3F)

IR break-beam: RX GPIO 32

Chute ultrasonic: TRIG GPIO 14, ECHO GPIO 27

Bin ultrasonic: TRIG GPIO 12, ECHO GPIO 13

HX711: DT GPIO 4, SCK GPIO 16

Solenoid (via MOSFET/relay): GPIO 25

Stepper (A4988): STEP GPIO 26, DIR GPIO 33, ENABLE GPIO 15

RFID MFRC522: SDA/SS GPIO 5, SCK GPIO 18, MOSI GPIO 23, MISO GPIO 19, RST GPIO 17

Keypad (optional): adjust in code or skip

Thermal printer (optional): UART2 TX GPIO 17 (if not used by RFID RST)

Use proper level shifting only where needed, flyback diode for solenoid, and a common ground for everything.

3) ESP32 firmware (Arduino IDE)

Shows live fill % on LCD

Validates bottle: IR present → (optional) diameter check → weight window

Drives auger/solenoid, debounces, anti-jam retry

Sends HTTP POST (JSON) to your backend

Has simple config section on top

Libraries to install (Library Manager):
LiquidCrystal_I2C, HX711, MFRC522, Keypad (optional)


Source Code 1: 

#include <WiFi.h>
#include <HTTPClient.h>
#include <LiquidCrystal_I2C.h>
#include "HX711.h"
#include <SPI.h>
#include <MFRC522.h>

/* ---------- USER CONFIG ---------- */
// Networking
const char* WIFI_SSID   = "YourWiFiSSID";
const char* WIFI_PASS   = "YourWiFiPassword";
String       SERVER_URL = "http://your.server.com/api/deposit"; // HTTP endpoint

// Machine IDs / policy
String MACHINE_ID       = "RVM-Dhaka-01";
float  BIN_HEIGHT_CM    = 70.0;       // interior bin height (top sensor to bottom)
float  FULL_THRESHOLD_CM= 12.0;       // if surface within 12cm of top => full
float  MIN_WEIGHT_G     = 8.0;        // reject items lighter than this (tune)
float  MAX_WEIGHT_G     = 120.0;      // reject very heavy (not a bottle)
float  MIN_DIAMETER_CM  = 4.0;        // optional size window (tune)
float  MAX_DIAMETER_CM  = 12.0;

// Mechanics
bool   USE_STEPPER      = true;       // true: auger/roller; false: solenoid drop
int    AUGER_STEPS_OPEN = 1600;       // steps to intake/clear one bottle
int    AUGER_FEED_MS    = 2500;       // safety timeout
int    JAM_RETRIES      = 2;

// Timings
unsigned long POST_GUARD_MS = 3000;   // min spacing between posts
unsigned long LCD_UPDATE_MS = 250;

// LCD
LiquidCrystal_I2C lcd(0x27, 20, 4);    // change to 0x3F if needed

/* ---------- PINS ---------- */
// IR beam
const int IR_PIN = 32; // active low if using common IR board

// Chute ultrasonic
const int CHUTE_TRIG = 14;
const int CHUTE_ECHO = 27;

// Bin ultrasonic (fill level)
const int BIN_TRIG = 12;
const int BIN_ECHO = 13;

// HX711 load cell
const int HX_DT = 4;
const int HX_SCK = 16;

// Solenoid
const int SOLENOID_PIN = 25;

// Stepper (A4988)
const int STEP_PIN = 26;
const int DIR_PIN  = 33;
const int EN_PIN   = 15;

// RFID MFRC522
const int RST_PIN  = 17;
const int SS_PIN   = 5;

/* ---------- Globals ---------- */
HX711 scale;
MFRC522 mfrc522(SS_PIN, RST_PIN);

unsigned long lastPostMs = 0;
unsigned long lastLCDMs  = 0;

float scaleFactor = 450.0f;  // adjust via calibration (grams per unit)
float scaleOffset = 0.0f;    // tare offset

/* ---------- Helpers ---------- */
float measureDistanceCm(int trig, int echo) {
  digitalWrite(trig, LOW); delayMicroseconds(2);
  digitalWrite(trig, HIGH); delayMicroseconds(10);
  digitalWrite(trig, LOW);
  long dur = pulseIn(echo, HIGH, 40000UL); // 40ms ~ 6.8m
  if (dur == 0) return NAN;
  return dur / 58.0f;
}

float clampf(float v, float lo, float hi) {
  if (v < lo) return lo;
  if (v > hi) return hi;
  return v;
}

String readRFID() {
  String id = "anonymous";
  if (!mfrc522.PICC_IsNewCardPresent()) return id;
  if (!mfrc522.PICC_ReadCardSerial())   return id;
  id = "";
  for (byte i = 0; i < mfrc522.uid.size; i++) {
    if (mfrc522.uid.uidByte[i] < 0x10) id += "0";
    id += String(mfrc522.uid.uidByte[i], HEX);
  }
  mfrc522.PICC_HaltA(); mfrc522.PCD_StopCrypto1();
  return id;
}

float readWeightGrams(uint8_t samples = 5) {
  long raw = 0;
  for (int i=0;i<samples;i++) raw += scale.read();
  raw /= samples;
  float grams = (raw - scaleOffset) / scaleFactor;
  return grams;
}

void stepperEnable(bool en) {
  digitalWrite(EN_PIN, en ? LOW : HIGH); // LOW = enable on many boards
}

void stepperMove(int steps, bool forward=true, int pulse_us=600) {
  digitalWrite(DIR_PIN, forward ? HIGH : LOW);
  for (int i=0;i<steps;i++) {
    digitalWrite(STEP_PIN, HIGH);
    delayMicroseconds(pulse_us);
    digitalWrite(STEP_PIN, LOW);
    delayMicroseconds(pulse_us);
  }
}

void solenoidPulse(int ms) {
  digitalWrite(SOLENOID_PIN, HIGH);
  delay(ms);
  digitalWrite(SOLENOID_PIN, LOW);
}

bool httpPost(String json) {
  if (WiFi.status() != WL_CONNECTED) return false;
  HTTPClient http;
  http.begin(SERVER_URL);
  http.addHeader("Content-Type", "application/json");
  int code = http.POST(json);
  http.end();
  return (code > 0 && code < 400);
}

void lcdLine(int row, const String& s) {
  String t = s; if (t.length() < 20) t += String(' ', 20 - t.length());
  lcd.setCursor(0, row);
  lcd.print(t.substring(0,20));
}

/* ---------- Setup ---------- */
void setup() {
  pinMode(IR_PIN, INPUT_PULLUP);

  pinMode(CHUTE_TRIG, OUTPUT); pinMode(CHUTE_ECHO, INPUT);
  pinMode(BIN_TRIG, OUTPUT);   pinMode(BIN_ECHO, INPUT);

  pinMode(SOLENOID_PIN, OUTPUT); digitalWrite(SOLENOID_PIN, LOW);

  pinMode(STEP_PIN, OUTPUT); pinMode(DIR_PIN, OUTPUT); pinMode(EN_PIN, OUTPUT);
  stepperEnable(false);

  lcd.init(); lcd.backlight();
  lcdLine(0, "Plastic Collector");
  lcdLine(1, "Booting...");

  // Weight scale
  scale.begin(HX_DT, HX_SCK);
  delay(200);
  scale.tare(); // quick tare (you’ll calibrate below)

  // RFID
  SPI.begin();
  mfrc522.PCD_Init();

  // WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  lcdLine(2, "WiFi: connecting");
  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) {
    delay(250);
  }
  lcdLine(2, WiFi.status()==WL_CONNECTED ? "WiFi: connected   " : "WiFi: offline     ");
  delay(400);
}

/* ---------- Main Loop ---------- */
void loop() {
  unsigned long now = millis();

  // Read bin fill level
  float binDist = measureDistanceCm(BIN_TRIG, BIN_ECHO);
  if (isnan(binDist)) binDist = BIN_HEIGHT_CM;
  float fillPct = 100.0f * clampf((BIN_HEIGHT_CM - binDist)/BIN_HEIGHT_CM, 0.0f, 1.0f);
  bool  isFull  = (binDist <= FULL_THRESHOLD_CM);

  // LCD refresh
  if (now - lastLCDMs >= LCD_UPDATE_MS) {
    lastLCDMs = now;
    lcdLine(0, "Plastic Collector");
    char l1[24]; snprintf(l1, sizeof(l1), "Fill:%3d%%  %s", (int)(fillPct+0.5f), isFull ? "FULL" : "OK  ");
    lcdLine(1, String(l1));
    char l2[24]; snprintf(l2, sizeof(l2), "BinTop:%5.1fcm", binDist);
    lcdLine(2, String(l2));
    lcdLine(3, WiFi.status()==WL_CONNECTED ? "NET:ONLINE" : "NET:OFFLINE");
  }

  // If full, stop accepting bottles
  if (isFull) {
    delay(200);
    return;
  }

  // Wait for bottle (IR beam broken = LOW on typical modules)
  if (digitalRead(IR_PIN) == LOW) {
    // Small settle delay
    delay(120);

    // Diameter (optional): ping across the chute
    float diaCm = NAN;
    float crossDist = measureDistanceCm(CHUTE_TRIG, CHUTE_ECHO);
    if (!isnan(crossDist)) {
      // If sensor is offset known amount from wall; for a quick gate assume tube ID ~ crossDist
      diaCm = crossDist; // calibrate: map sensor reading to approximate diameter
    }

    // Weight check: capture item on small tray (mechanical design)
    float g = readWeightGrams(8);

    bool sizeOK   = isnan(diaCm) ? true : (diaCm >= MIN_DIAMETER_CM && diaCm <= MAX_DIAMETER_CM);
    bool weightOK = (g >= MIN_WEIGHT_G && g <= MAX_WEIGHT_G);

    // Decide validity
    bool valid = sizeOK && weightOK;

    // Actuate
    bool moved = false;
    if (valid) {
      if (USE_STEPPER) {
        stepperEnable(true);
        unsigned long start = millis();
        stepperMove(AUGER_STEPS_OPEN, true);
        moved = (millis() - start) < AUGER_FEED_MS;
        // anti-jam retries (reverse/forward)
        int tries = 0;
        while (!moved && tries < JAM_RETRIES) {
          stepperMove(AUGER_STEPS_OPEN/3, false);
          stepperMove(AUGER_STEPS_OPEN, true);
          tries++;
          moved = true; // assume OK; add current-sense for realism
        }
        stepperEnable(false);
      } else {
        solenoidPulse(450); // drop item
        moved = true;
      }
    } else {
      // reject: reverse auger a bit or blink LCD notice
      if (USE_STEPPER) {
        stepperEnable(true);
        stepperMove(AUGER_STEPS_OPEN/3, false);
        stepperEnable(false);
      }
    }

    // Compose record & POST
    if (now - lastPostMs >= POST_GUARD_MS) {
      lastPostMs = now;
      String rfid = readRFID(); // "anonymous" if none
      // Build JSON
      String json = String("{")
        + "\"machine_id\":\"" + MACHINE_ID + "\","
        + "\"user_id\":\""    + rfid + "\","
        + "\"valid\":"        + (valid ? "true":"false") + ","
        + "\"weight_g\":"     + String(g,1) + ","
        + "\"diameter_cm\":"  + (isnan(diaCm) ? String("null") : String(diaCm,1)) + ","
        + "\"bin_fill_pct\":" + String((int)(fillPct+0.5f)) + ","
        + "\"timestamp\":"    + String((unsigned long)(millis()/1000)) + "}";
      bool ok = httpPost(json);

      // LCD feedback
      if (valid && moved) {
        lcdLine(3, ok ? "Accepted: +1      " : "Accepted: offline");
      } else {
        lcdLine(3, "Rejected item      ");
      }
      delay(600);
    }

    // Debounce: wait until beam returns
    unsigned long t1 = millis();
    while (digitalRead(IR_PIN) == LOW && millis() - t1 < 3000) { delay(10); }
  }

  // small idle delay
  delay(10);
}

Source code 2: Minimal web backend (Node.js + Express)
// server.js
import express from "express";
import cors from "cors";
import bodyParser from "body-parser";

const app = express();
app.use(cors());
app.use(bodyParser.json());

const deposits = []; // in-memory (replace with DB)

app.post("/api/deposit", (req, res) => {
  const rec = {
    ...req.body,
    server_ts: Date.now()
  };
  deposits.push(rec);
  console.log("Deposit:", rec);
  res.status(200).json({ ok: true });
});

app.get("/api/stats", (req, res) => {
  const total = deposits.filter(d => d.valid).length;
  const weight = deposits
    .filter(d => d.valid && typeof d.weight_g === "number")
    .reduce((s,d)=>s+d.weight_g,0);
  res.json({ total_valid: total, total_weight_g: Math.round(weight) });
});

app.listen(3000, () => console.log("API on http://0.0.0.0:3000"));


5) Mechanical notes (quick)

Chute: ~10–12 cm ID tube with rubber “fingers” to slow bounce. Angle slightly downward to the auger.

Capture tray sits on the load cell before auger engages, so you weigh before committing.

Anti-jam: Auger/roller with coarse rubber sleeve; add a hall sensor or current sense for real jam detection.

Service door with reed switch to disable motor when open.

Bin liner with frame; position the bin ultrasonic at top center pointing down.

Thermal management: Keep electronics enclosure ventilated; separate mains from logic in different compartments if you add AC PSU.

6) Safety & reliability checklist

Solenoid/driver with flyback diode; stepper driver heat-sink and current limit set properly.

Fuses on 12 V rail; E-stop in series with motor supply.

Grounding: common GND; star grounding to reduce sensor noise.

Isolation: keep HX711 wiring short & shielded; route away from motor lines.

Watchdog: for production, enable ESP32 watchdog and add Wi-Fi reconnect logic.

Enclosure: no exposed pinch points; add guards around auger.

7) Next upgrades (ask me if you want them now)

Receipt/QR printer for coupons (TTL thermal printer)

On-device menu for calibration & network setup

HTTPS + JWT auth, or MQTT for streaming to your cloud

Vision check (ESP32-S3 + tiny camera) to better classify PET vs others

Two-stream reward logic (weight-based + bottle count)

